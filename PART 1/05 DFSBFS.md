# chapter05 DFS/BFS   
## 꼭 필요한 자료구조 기초   
***탐색*** 이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정을 의미한다. 
프로그래밍에서는 그래프, 트리 등의 자료구조 안에서 탐색을 하는 문제를 자주 다룬다.
대표적인 탐색 알고리즘으로 DFS와 BFS를 꼽을 수 있는데 이 두 알고리즘의 원리를 제대로 이해해야 코딩 테스트의 탐색 문제 유형을 풀 수 있다.   
***자료구조*** 란 '데이터를 표현하고 관리하고 처리하기 위한 구조'를 의미한다. 
그 중 스택과 큐는 자료구조의 기초 개념으로 다음의 두 핵심적인 함수로 구성된다.
- 삽입(push) : 데이터를 삽입한다
- 삭제(pop) : 데이터를 삭제한다

<br/>
<br/>

***스택(stack)*** 은 박스 쌓기에 비유할 수 있다.
흔히 박스는 아래에서부터 위로 쌓는다.
이러한 구조를 선입후출구조 혹은 후입선출구조라고 한다.   

   
#### 스택 예제(5-1.py)
```python
stack = []

# 삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()
stack.append(5)
stack.append(2)
stack.append(3)
stack.append(7)
stack.pop()         #7이 사라짐
stack.append(1)
stack.append(4)
stack.pop()         #4가 사라짐

print(stack)        #최하단 원소부터 출력
print(stack[::-1])  #최상단 원소부터 출력
```

<br/>
<br/>

***큐(queue)*** 는 대기 줄에 비유할 수 있다.
흔히 놀이공원에 입장하기 위해 줄을 설 때, 먼저 온 사람이 먼저 들어가게 된다.
이러한 구조를 선입선출구조라고 한다.

#### 큐 예제(5-2.py)
```python
from collections import deque

# 큐(queue) 구현을 위해 deque라이브라리 사용
queue = deque()

# 삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()
queue.append(5)
queue.append(2)
queue.append(3)
queue.append(7)
queue.popleft()  #5가 사라짐
queue.append(1)
queue.append(4)
queue.popleft()  #2가 사라짐

print(queue)     #먼저 들어온 순서대로 출력
queue.reverse()  #다음 출력을 위해 역순으로 바꾸기
print(queue)     #나중에 들어온 원소부터 출력
````

<br/>
<br/>

***재귀함수(recursive function)*** 란 자기자신을 다시 호출하는 함수를 의미한다.
가장 간단한 재귀함수는 다음과 같다.

#### 재귀 함수 예제(5-3.py)
```python
def recursive_function():
    print('재귀 함수를 호출합니다.')
    recursive_function()
    
recursive_function()
````

이 코드를 실행하면 '재귀 함수를 호출합니다.'라는 문자열을 무한히 출력한다. 
여기에서 정의한 recursive_function이 자기 자신을 계속해서 추가로 불러오기 때문이다.
따라서 재귀함수를 문제 풀이에서 사용할 때는 재귀함수가 언제 끝날지, 종료 조건을 꼭 명시해야한다.
예를 들어 다음은 재귀함수를 100번 호출하도록 작성한 코드이다.
재귀함수 초반에 등장하는 if문이 종료 조건 역할을 수행한다.

#### 재귀 함수 예제(5-3.py)
```python
def recursive_function(i):
    #100번째 출력했을 때 종료되도록 종료 조건 명시
    if i == 100:
        return
    print(i, '번째 재귀 함수에', i+1, '번째 재귀 함수를 호출합니다.')
    recursive_function(i+1)
    print(i, '번째 재귀 함수를 종료합니다.')

recursive_function(1)
```

<br/>

재귀 함수를 이용하는 대표적 예제로는 팩토리얼 문제가 있다.
팩토리얼을 반복적으로 구현한 방식과 재귀적으로 구현한 두 방식을 비교해보자.
```python
#반복적으로 구현한 n!
def factorial_iterative(n):
    result = 1
    #1부터 n까지의 수를 차례대로 곱하기
    for i in range(1, n+1):
        result *= i
    return result

#재귀적으로 구현한 n!
def factorial_recursive(n):
    if n <= 1:    #n이 1 이하인 경우 1을 반환
        return 1
    #n! = n*(n-1)!를 그대로 코드 작성하기
    return n*factorial_recursive(n-1)

print('반복적으로 구현:', factorial_iterative(5))
print('재귀적으로 구현', factorial_recursive(5))
````
반복문 대신에 재귀 함수를 사용했을 때, 코드거 더 간결한 것을 알 수 있다.
재귀 함수가 수학의 점화식(재귀식)을 그대로 소스 코드로 옮겼기 때문이다.

<br/>
<br/>

## 탐색 알고리즘 DFS/BFS

### DFS
***DFS*** 는 Depth-First Search, 깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.
DFS를 이해하기 위해서는 그래프의 기본 구조를 알아야한다.
그래프는 ***노드*** 와 ***간선*** 으로 표현되며 이 때 노드를 ***정점***이라고도 말한다.
그래프 탐색이란, 하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말한다.
또한 두 노드가 간선으로 연결되어있다면, '두 노드는 인접하다'라고 표현한다.
프로그래밍에서 그래프는 크게 두 가지 방식으로 표현할 수 있는데, 코딩 테스트에서는 이 두 방식 모두 필요하니 두 개념에 대해 바르게 알고 있도록 하자.

 - 인접 행렬(Adjacency Matrix): 2차원 배열로 그래프의 연결 관계를 표현하는 방식
 - 인접 리스트(Adjacency List): 리스트로 그래프의 연결 관계를 표현하는 방식

<br/>

|  *  |  0  |  1  |  2  |
|:---:|:---:|:---:|:---:|
|  0  |  0  |  7  |  5  |
|  1  |  7  |  0  | 무한 |
|  2  |  5  | 무한 |  0  | 
 
먼저, ***인접 행렬(Adjacency Matrix)*** 이란 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식이다.
이와 같이 연결된 그래프를 인접 행렬로 표현할 때 파이썬에서는 2차원 리스트로 구현할 수 있다.
연결이 되어있지않은 노드끼리는 무한의 비용이라고 작성한다.
이렇게 그래프를 인접 행렬 방식으로 처리할 때는 다음과 같이 데이터를 초기화한다.

#### 인접 행렬 방식 예제(5-6.py)
```python
INF = 999999999  #무한의 비용 선언

#2차원 리스트를 이용해 인접 행렬 표현
graph = [
    [0, 7, 5],
    [7, 0, INF],
    [5, INF, 0]
]

print(graph)
```

```python
[[0, 7, 5], [7, 0, 999999999], [5, 999999999, 0]]
```

<br/>

```
0 -> 1 -> 2
1 -> 0
2 -> 0
```

***인접 리스트(Adjacency List)*** 방식에서는 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장한다.
인접 리스트는 '연결 리스트
